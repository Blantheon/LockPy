from cryptography.fernet import Fernet, InvalidToken
from getpass import getuser
from base64 import urlsafe_b64encode
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import apsw
from io import BytesIO

PATH = '/home/' + getuser() + '/Desktop/lockpy/sql'


class Cryptography():
    def __init__(self) -> None:
        self.key: bytes
        self.pbkdf_derivation()
        self.f = Fernet(self.key)

    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        del self.key
        del self.f

    def pbkdf_derivation(self) -> None:
        # salt is an abitrary value generated by os.urandom(16)
        salt = b'\xae\xb7Y\x00R+\x19fw\xe31(r`\x817'
        password = input('Enter the password of the database: ').encode()
        pbkdf = PBKDF2HMAC(hashes.SHA256(), 32, salt, 1_000_000)
        self.key = urlsafe_b64encode(pbkdf.derive(password))

    def encrypt(self, data: bytes | str) -> None:
        if isinstance(data, str):
            data = data.decode()
        encrypted_data: bytes = self.f.encrypt(data)
        with open(f'{PATH}/database.lp', 'wb') as f:
            f.write(encrypted_data)

    def decrypt(self, data_encrypted: bytes) -> None:
        try:
            decrypted_data =  self.f.decrypt(data_encrypted)
        except InvalidToken:
            raise InvalidToken('The password entered is invalid')
        
        return decrypted_data

# these VFS are used to read the data into the memory and avoid writing it in clear
class VFSRamOnly(apsw.VFS):
    def __init__(self, data, vfsname="ramonly", basevfs=""):
        self.vfs_name = vfsname
        self.base_vfs = basevfs
        self.data = data
        self.files: VFSRamOnlyFiles
        super().__init__(self.vfs_name, self.base_vfs)

    def xOpen(self, name, flags) -> None:
        self.files = VFSRamOnlyFiles(self.base_vfs, name, flags, self.data)
        return self.files


class VFSRamOnlyFiles(apsw.VFSFile):
    def __init__(self, inheritfromvfsname, filename, flags, data):
        self.buffer = data
        super().__init__(inheritfromvfsname, filename, flags)
    
    def xRead(self, amount, offset):
        self.buffer.seek(offset)
        data = self.buffer.read(amount)
        if len(data) < amount:
            data += b'\x00' * (amount - len(data))
        return data

    def xWrite(self, data, offset):
        current = len(self.buffer.getvalue())
        end = len(data) + offset
        if current < end:
            self.buffer.seek(0,2)
            self.buffer.write(b'\x00' * (end - current))
        
        self.buffer.seek(offset)
        self.buffer.write(data)

    def xTruncate(self, size):
        super().xTruncate()

    def xFileSize(self):
        return len(self.buffer.getvalue())

if __name__ == '__main__':
    e = Cryptography()

        