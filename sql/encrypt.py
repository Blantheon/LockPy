from cryptography.fernet import Fernet, InvalidToken
from getpass import getuser
from base64 import urlsafe_b64encode
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import apsw
from io import BytesIO
# for tests
import sqlite3

PATH = '/home/' + getuser() + '/Desktop/lockpy/sql'


class Encryption():
    def __init__(self) -> None:
        self.pbkdf_derivation()
        self.f = Fernet(self.key)

    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        # implement an errasing of the secret key in memory
        ...

    def pbkdf_derivation(self) -> None:
        # salt is an abitrary value generated by os.urandom(16)
        salt = b'\xae\xb7Y\x00R+\x19fw\xe31(r`\x817'
        password = input('Enter the password of the database: ').encode()
        pbkdf = PBKDF2HMAC(hashes.SHA256(), 32, salt, 1_000_000)
        self.key = urlsafe_b64encode(pbkdf.derive(password))

    def encrypt(self, data: bytes | str) -> None:
        if isinstance(data, str):
            data = data.decode()
        encrypted_data: bytes = self.f.encrypt(data)
        with open(f'{PATH}/database.lp.enc', 'wb') as f:
            f.write(encrypted_data)

    def decrypt(self, data: bytes) -> None:
        try:
            decrypted_data =  self.f.decrypt(data)
        except InvalidToken:
            raise InvalidToken('The password entered is invalid')
        
        return decrypted_data


if __name__ == '__main__':
    e = Encryption()
    '''with open(f'{PATH}/database.lp', 'rb') as f1:
        d = f1.read()
        e.encrypt(d)'''
    with open(f'{PATH}/database.lp.enc', 'rb') as f2:
        enc = f2.read()
        data = e.decrypt(enc)

    obj = BytesIO(data)
    con = apsw.Connection(':memory', vfs=obj)