from cryptography.fernet import Fernet, InvalidToken
from getpass import getuser
from base64 import urlsafe_b64encode
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import apsw
from io import BytesIO

PATH = '/home/' + getuser() + '/Desktop/lockpy/sql'


class Cryptography():
    def __init__(self) -> None:
        self.pbkdf_derivation()
        self.f = Fernet(self.key)

    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        # implement an errasing of the secret key in memory
        ...

    def pbkdf_derivation(self) -> None:
        # salt is an abitrary value generated by os.urandom(16)
        salt = b'\xae\xb7Y\x00R+\x19fw\xe31(r`\x817'
        password = input('Enter the password of the database: ').encode()
        pbkdf = PBKDF2HMAC(hashes.SHA256(), 32, salt, 1_000_000)
        self.key = urlsafe_b64encode(pbkdf.derive(password))

    def encrypt(self, data: bytes | str) -> None:
        if isinstance(data, str):
            data = data.decode()
        encrypted_data: bytes = self.f.encrypt(data)
        with open(f'{PATH}/test.lp.enc', 'wb') as f:
            f.write(encrypted_data)

    def decrypt(self, data_encrypted: bytes) -> None:
        try:
            decrypted_data =  self.f.decrypt(data_encrypted)
        except InvalidToken:
            raise InvalidToken('The password entered is invalid')
        
        return decrypted_data

# these VFS are used to read the data into the memory and avoid writing it in clear
class VFSRamOnly(apsw.VFS):
    def __init__(self, data, vfsname="ramonly", basevfs=""):
        self.vfs_name = vfsname
        self.base_vfs = basevfs
        self.data = data
        self.files: VFSRamOnlyFiles
        super().__init__(self.vfs_name, self.base_vfs)

    def xOpen(self, name, flags) -> None:
        self.files = VFSRamOnlyFiles(self.base_vfs, name, flags, self.data)
        return self.files


class VFSRamOnlyFiles(apsw.VFSFile):
    def __init__(self, inheritfromvfsname, filename, flags, data):
        self.buffer = data
        super().__init__(inheritfromvfsname, filename, flags)
    
    def xRead(self, amount, offset):
        self.buffer.seek(offset)
        data = self.buffer.read(amount)
        if len(data) < amount:
            data += b'\x00' * (amount - len(data))
        return data

    def xWrite(self, data, offset):
        current = len(self.buffer.getvalue())
        end = len(data) + offset
        if current < end:
            self.buffer.seek(0,2)
            self.buffer.write(b'\x00' * (end - current))
        
        self.buffer.seek(offset)
        self.buffer.write(data)

    def xTruncate(self, size):
        self.buffer.seek(0)
        self.buffer.truncate(size)

    def xFileSize(self):
        return len(self.buffer.getvalue())

if __name__ == '__main__':
    e = Cryptography()
    '''with open(f'{PATH}/database.lp', 'rb') as f1:
        d = f1.read()
        e.encrypt(d)
    '''
    
    with open(f'{PATH}/database.lp.enc', 'rb') as f2:
        encrypted_data = f2.read()
        vfs_object: VFSRamOnly = e.decrypt(encrypted_data)
        con = apsw.Connection('test.db', vfs=vfs_object.vfs_name)
        con.execute('''CREATE TABLE hi(\
                        name TEXT PRIMARY KEY NOT NULL,\
                        user TEXT,\
                        password TEXT NOT NULL,\
                        url TEXT,\
                        description TEXT);''')
        con.execute('''INSERT INTO hi VALUES ("Blant","Heon", "M", NULL, NULL)''')
        con.execute('''INSERT INTO hi VALUES ("google","googleman", "passW", "https://google.com", "A Big Description")''')
        for i in con.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='hi';"):
            print(i)

        lines = [i for i in con.execute("SELECT * FROM hi")]
        print(lines)
        
        if not lines: print('ok not lines')
        for line in lines:
            print(line)

        